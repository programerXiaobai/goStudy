标准输入：
fmt.Scanln(&a) 读取一行的数据，输入的时候必须有换行符，遇到换行符 Scanln 就结束。传入地址是因为指针传递，在函数内部修改 a，外部就也修改了
fmt.Scanf("%d %s %f", &age,&name,&score)  从标准输入中根据空白分隔的值将输入保存到函数的参数。返回成功扫描的参数个数和遇到的错误

break:
在 switch 中，每个 case 后不需要写 break，因为 go 中默认添加了
break 可以结束指定标签对应的循环
break 可以结束内层循环，如果想直接结束外层循环，可以在外层循环的for的上一行加一个 label:，然后 break 的时候直接 break label，就直接break 外层了

同理 continue 可以是continue内层循环，当然 continue 后也可以加一个 label 可以直接continue外层循环 或者 label 定义的位置

goto 不建议使用：无条件跳到某个 label

switch后跟一个表达式（常量、变量、一个有返回值的函数）
case后面可以跟多个值，比如 case 值1,值2...
因为case后面不需要跟 break，但是如果想穿透的话就在 case 后加 fallthrough，则执行完一个 case，会继续下一个 case。fallthrough 默认穿透一个case
switch 后可以直接声明一个变量，分号结束，比如 switch b := 7; {}
switch 后也可以不带表达式，当作 if 分支使用，比如 switch {case a == 1:    case a == 2: }

闭包：一个函数和其相关的引用环境组合的一个整体
匿名函数中引用的那个变量会一直保存在内存中，可以一直使用
闭包的本质就是一个匿名函数，只不过是在这个函数引入外界的变量/函数，所以 匿名函数+引用的变量/参数 = 闭包
不建议使用闭包，比如下面的例子可以直接将 sum 拿出作为全局变量，这样一个函数就能解决了，不需要闭包

匿名函数：
在定义匿名函数的时候直接调用，也就是定义之后加上() 进行调用
将匿名函数赋给一个变量（该变量就是函数变量了），通过该变量来调用匿名函数。比如 sub := func(a, b int) int { return a - b }

go 中没有专门字符类型，如果要存储单个字符，一般使用 byte 来保存
go 中字符使用的是 utf-8 编码
var c1 byte = 'a' //记录的是 a 的 acii 码，因为字符类型本质就是整数，所以打印就是 97
var c2 byte = '中' //'中' 记录的是utf8编码，编码值是20013，而 byte记录的范围是0~255，所以不能用 byte，可以用 int、uint、rune
上述 c1 和 c2 直接 fmt.Println 打印的就是编码值，如果想打印这个字符的话用 fmt.Printf("%c")

基本数据类型转string：
方式1：使用 fmt.Sprintf("%参数", 表达式)       fmt.Sprintf("%d", num)，如果 num是int的话      fmt.Sprintf("%f", num)，如果num是float
方式2：使用 strconv 包的函数  strconv.FormatBool() strconv.FormatInt()  strconv.FormatUint()  strconv.FormatFloat
string 转基本数据类型
使用 strconv 包的函数  strconv.ParseBool()  strconv.ParseInt()   strconv.ParseUint()    strconv.ParseFloat()

1. len(str) 统计字符串的长度，按字节进行统计,汉字是utf-8字符集，一个汉字3个字节
2. r := []rune(str) 字符串转字符切片
3. n, err := strconv.Atoi("66") 字符串转整数
4. str = strconv.Itoa(66) 整数转字符串
5. strings.Contains("java and golang", "go") 查找字串是否在指定的字符串中
6. strings.Count("java and golang", "a") 统计一个字符串有几个指定的字串
7. strings.EqualFold("go", "Go") 不区分大小写的进行字符串比较
8. strings.Index("java and golang", "a") 返回字串在字符串第一次出现的索引值，如果没有返回-1
9. strings.Replace("goandjavagogo", "go", "golang", "n") 字符串替换，将字符串中的 go 换成 golang，n=-1表示全部替换，替换两个n=2
10. strings.Split("go-python-java", "-") 按照指定的某个字符进行分割，返回拆分成的字符数串组
11. strings.ToLower("Go") 转小写
12. strings.ToUpper("go") 转大写
13. strings.TrimSpace("  go java  ") 去掉字符串左右两边的空格
14. strings.Trim("~golang~, "~") 去掉字符串左右两边的指定字符
15. strings.TrimLeft("~golang~, "~") 去掉字符串左边的指定字符
16. strings.TrimRight("~golang~, "~") 去掉字符串右边的指定字符
17. strings.HasPrefix("http://java.sun.com", "http") 判断字符串是否以指定的字符串开头
18. strings.HasSuffix("demo.png", ".png") 判断字符串是否以指定的字符串结尾

日期和时间的函数，需要导入 time 包，所以获取当前时间，就需要调用 Now 函数
now := time.Now()  now 是Time 类型，Time 是一个 struct
now.Year, now.Month, now.Date, now.Clock  获取年，月，日，时分秒
可以进行日期的格式化：
datestr := fmt.Sprintf("日期：%d-%d-%d %d:%d:%d", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())
datestr := now.Format("2006/01/02 15/04/05")  ""中的时间必须写这个时间，这样才能识别处理，格式化成这样的形式

内置函数：不需要导报就能用的函数，其实是属于 builtin 包，只不过不需要导这个包
len：返回长度
new：分配内存，第一个参数是类型，不是值，返回值是指向该类型新分配的零值的指针。比如  iPtr := new(int) 	*iPtr = 10
    new 主要是分配值类型（int, float, bool, string, struct, 数组）
make：分配内存，主要用来分配引用类型（指针，slice切片，map，管道chan，interface）

错误处理（C++中称之为异常处理）
如果程序出错，会报 panic，后面跟的就是错误，比如 runtime error：integer divide by zero
错误处理的捕获机制：defer + recover，一般使用defer+匿名函数，匿名函数中写 recover 捕获异常
异常捕获之后后面的代码仍然会执行

异常处理：自定义错误
使用 errors 包中 New 来自定义一个错误   func New(str string) error
比如 err := errors.New("除数不能为0")，这个函数可以返回 err error 即可，其他函数可以接收这个返回值
这样其他函数捕获异常之后，打印这个异常，后面的逻辑仍然能够执行
但是如果这个异常很重要，不想执行后面的逻辑的话，就使用 builtin 包中的 panic 函数，比如 panic(err) 直接退出程序

切片的底层本质不是数组，就是一个 struct，包含3个成员：执行底层数组的指针，切片的长度，切片的容量

struct 绑定方法可以这样：type A struct{}  func (a A) test() {} 不一定非得 (this A)
如果是指针传递：
func (p *Person) test() {}
调用： var p Person    (&p).test() 或 p.test()

go 中方法作用在指定的数据类型上，和指定的数据类型绑定，因此自定义类型struct 都可以有方法，int,float 等也可以有

如果一个类型实现了 String() 方法，那么 fmt.Println 会默认调用这个变量的 String() 进行输出
func (s *Student) String() string { return fmt.Sprintf("name:%s,age:%d", s.name, s.age) }





